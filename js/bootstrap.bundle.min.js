/*!
 * Bootstrap v5.3.3 (https://getbootstrap.com/)
 * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 */
! function (t, e) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).bootstrap = e()
}(this, (function () {
            "use strict";
            const t = new Map,
                e = {
                    set(e, i, n) {
                        t.has(e) || t.set(e, new Map);
                        const s = t.get(e);
                        s.has(i) || 0 === s.size ? s.set(i, n) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(s.keys())[0]}.`)
                    },
                    get: (e, i) => t.has(e) && t.get(e).get(i) || null,
                    remove(e, i) {
                        if (!t.has(e)) return;
                        const n = t.get(e);
                        n.delete(i), 0 === n.size && t.delete(e)
                    }
                },
                i = "transitionend",
                n = t => (t && window.CSS && window.CSS.escape && (t = t.replace(/#([^\s"#']+)/g, ((t, e) => `#${CSS.escape(e)}`))), t),
                s = t => {
                    t.dispatchEvent(new Event(i))
                },
                o = t => !(!t || "object" != typeof t) && (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType),
                r = t => o(t) ? t.jquery ? t[0] : t : "string" == typeof t && t.length > 0 ? document.querySelector(n(t)) : null,
                a = t => {
                    if (!o(t) || 0 === t.getClientRects().length) return !1;
                    const e = "visible" === getComputedStyle(t).getPropertyValue("visibility"),
                        i = t.closest("details:not([open])");
                    if (!i) return e;
                    if (i !== t) {
                        const e = t.closest("summary");
                        if (e && e.parentNode !== i) return !1;
                        if (null === e) return !1
                    }
                    return e
                },
                l = t => !t || t.nodeType !== Node.ELEMENT_NODE || !!t.classList.contains("disabled") || (void 0 !== t.disabled ? t.disabled : t.hasAttribute("disabled") && "false" !== t.getAttribute("disabled")),
                c = t => {
                    if (!document.documentElement.attachShadow) return null;
                    if ("function" == typeof t.getRootNode) {
                        const e = t.getRootNode();
                        return e instanceof ShadowRoot ? e : null
                    }
                    return t instanceof ShadowRoot ? t : t.parentNode ? c(t.parentNode) : null
                },
                h = () => {},
                d = t => {
                    t.offsetHeight
                },
                u = () => window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null,
                f = [],
                p = () => "rtl" === document.documentElement.dir,
                m = t => {
                    var e;
                    e = () => {
                        const e = u();
                        if (e) {
                            const i = t.NAME,
                                n = e.fn[i];
                            e.fn[i] = t.jQueryInterface, e.fn[i].Constructor = t, e.fn[i].noConflict = () => (e.fn[i] = n, t.jQueryInterface)
                        }
                    }, "loading" === document.readyState ? (f.length || document.addEventListener("DOMContentLoaded", (() => {
                        for (const t of f) t()
                    })), f.push(e)) : e()
                },
                g = (t, e = [], i = t) => "function" == typeof t ? t(...e) : i,
                _ = (t, e, n = !0) => {
                    if (!n) return void g(t);
                    const o = (t => {
                        if (!t) return 0;
                        let {
                            transitionDuration: e,
                            transitionDelay: i
                        } = window.getComputedStyle(t);
                        const n = Number.parseFloat(e),
                            s = Number.parseFloat(i);
                        return n || s ? (e = e.split(",")[0], i = i.split(",")[0], 1e3 * (Number.parseFloat(e) + Number.parseFloat(i))) : 0
                    })(e) + 5;
                    let r = !1;
                    const a = ({
                        target: n
                    }) => {
                        n === e && (r = !0, e.removeEventListener(i, a), g(t))
                    };
                    e.addEventListener(i, a), setTimeout((() => {
                        r || s(e)
                    }), o)
                },
                b = (t, e, i, n) => {
                    const s = t.length;
                    let o = t.indexOf(e);
                    return -1 === o ? !i && n ? t[s - 1] : t[0] : (o += i ? 1 : -1, n && (o = (o + s) % s), t[Math.max(0, Math.min(o, s - 1))])
                },
                v = /[^.]*(?=\..*)\.|.*/,
                y = /\..*/,
                w = /::\d+$/,
                A = {};
            let E = 1;
            const T = {
                    mouseenter: "mouseover",
                    mouseleave: "mouseout"
                },
                C = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);

            function O(t, e) {
                return e && `${e}::${E++}` || t.uidEvent || E++
            }

            function x(t) {
                const e = O(t);
                return t.uidEvent = e, A[e] = A[e] || {}, A[e]
            }

            function k(t, e, i = null) {
                return Object.values(t).find((t => t.callable === e && t.delegationSelector === i))
            }

            function L(t, e, i) {
                const n = "string" == typeof e,
                    s = n ? i : e || i;
                let o = I(t);
                return C.has(o) || (o = t), [n, s, o]
            }

            function S(t, e, i, n, s) {
                if ("string" != typeof e || !t) return;
                let [o, r, a] = L(e, i, n);
                if (e in T) {
                    const t = t => function (e) {
                        if (!e.relatedTarget || e.relatedTarget !== e.delegateTarget && !e.delegateTarget.contains(e.relatedTarget)) return t.call(this, e)
                    };
                    r = t(r)
                }
                const l = x(t),
                    c = l[a] || (l[a] = {}),
                    h = k(c, r, o ? i : null);
                if (h) return void(h.oneOff = h.oneOff && s);
                const d = O(r, e.replace(v, "")),
                    u = o ? function (t, e, i) {
                        return function n(s) {
                            const o = t.querySelectorAll(e);
                            for (let {
                                    target: r
                                } = s; r && r !== this; r = r.parentNode)
                                for (const a of o)
                                    if (a === r) return P(s, {
                                        delegateTarget: r
                                    }), n.oneOff && N.off(t, s.type, e, i), i.apply(r, [s])
                        }
                    }(t, i, r) : function (t, e) {
                        return function i(n) {
                            return P(n, {
                                delegateTarget: t
                            }), i.oneOff && N.off(t, n.type, e), e.apply(t, [n])
                        }
                    }(t, r);
                u.delegationSelector = o ? i : null, u.callable = r, u.oneOff = s, u.uidEvent = d, c[d] = u, t.addEventListener(a, u, o)
            }

            function D(t, e, i, n, s) {
                const o = k(e[i], n, s);
                o && (t.removeEventListener(i, o, Boolean(s)), delete e[i][o.uidEvent])
            }

            function $(t, e, i, n) {
                const s = e[i] || {};
                for (const [o, r] of Object.entries(s)) o.includes(n) && D(t, e, i, r.callable, r.delegationSelector)
            }

            function I(t) {
                return t = t.replace(y, ""), T[t] || t
            }
            const N = {
                on(t, e, i, n) {
                    S(t, e, i, n, !1)
                },
                one(t, e, i, n) {
                    S(t, e, i, n, !0)
                },
                off(t, e, i, n) {
                    if ("string" != typeof e || !t) return;
                    const [s, o, r] = L(e, i, n), a = r !== e, l = x(t), c = l[r] || {}, h = e.startsWith(".");
                    if (void 0 === o) {
                        if (h)
                            for (const i of Object.keys(l)) $(t, l, i, e.slice(1));
                        for (const [i, n] of Object.entries(c)) {
                            const s = i.replace(w, "");
                            a && !e.includes(s) || D(t, l, r, n.callable, n.delegationSelector)
                        }
                    } else {
                        if (!Object.keys(c).length) return;
                        D(t, l, r, o, s ? i : null)
                    }
                },
                trigger(t, e, i) {
                    if ("string" != typeof e || !t) return null;
                    const n = u();
                    let s = null,
                        o = !0,
                        r = !0,
                        a = !1;
                    e !== I(e) && n && (s = n.Event(e, i), n(t).trigger(s), o = !s.isPropagationStopped(), r = !s.isImmediatePropagationStopped(), a = s.isDefaultPrevented());
                    const l = P(new Event(e, {
                        bubbles: o,
                        cancelable: !0
                    }), i);
                    return a && l.preventDefault(), r && t.dispatchEvent(l), l.defaultPrevented && s && s.preventDefault(), l
                }
            };

            function P(t, e = {}) {
                for (const [i, n] of Object.entries(e)) try {
                    t[i] = n
                } catch (e) {
                    Object.defineProperty(t, i, {
                        configurable: !0,
                        get: () => n
                    })
                }
                return t
            }

            function j(t) {
                if ("true" === t) return !0;
                if ("false" === t) return !1;
                if (t === Number(t).toString()) return Number(t);
                if ("" === t || "null" === t) return null;
                if ("string" != typeof t) return t;
                try {
                    return JSON.parse(decodeURIComponent(t))
                } catch (e) {
                    return t
                }
            }

            function M(t) {
                return t.replace(/[A-Z]/g, (t => `-${t.toLowerCase()}`))
            }
            const F = {
                setDataAttribute(t, e, i) {
                    t.setAttribute(`data-bs-${M(e)}`, i)
                },
                removeDataAttribute(t, e) {
                    t.removeAttribute(`data-bs-${M(e)}`)
                },
                getDataAttributes(t) {
                    if (!t) return {};
                    const e = {},
                        i = Object.keys(t.dataset).filter((t => t.startsWith("bs") && !t.startsWith("bsConfig")));
                    for (const n of i) {
                        let i = n.replace(/^bs/, "");
                        i = i.charAt(0).toLowerCase() + i.slice(1, i.length), e[i] = j(t.dataset[n])
                    }
                    return e
                },
                getDataAttribute: (t, e) => j(t.getAttribute(`data-bs-${M(e)}`))
            };
            class H {
                static get Default() {
                    return {}
                }
                static get DefaultType() {
                    return {}
                }
                static get NAME() {
                    throw new Error('You have to implement the static method "NAME", for each component!')
                }
                _getConfig(t) {
                    return t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t
                }
                _configAfterMerge(t) {
                    return t
                }
                _mergeConfigObj(t, e) {
                    const i = o(e) ? F.getDataAttribute(e, "config") : {};
                    return {
                        ...this.constructor.Default,
                        ..."object" == typeof i ? i : {},
                        ...o(e) ? F.getDataAttributes(e) : {},
                        ..."object" == typeof t ? t : {}
                    }
                }
                _typeCheckConfig(t, e = this.constructor.DefaultType) {
                    for (const [n, s] of Object.entries(e)) {
                        const e = t[n],
                            r = o(e) ? "element" : null == (i = e) ? `${i}` : Object.prototype.toString.call(i).match(/\s([a-z]+)/i)[1].toLowerCase();
                        if (!new RegExp(s).test(r)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${n}" provided type "${r}" but expected type "${s}".`)
                    }
                    var i
                }
            }
            class W extends H {
                constructor(t, i) {
                    super(), (t = r(t)) && (this._element = t, this._config = this._getConfig(i), e.set(this._element, this.constructor.DATA_KEY, this))
                }
                dispose() {
                    e.remove(this._element, this.constructor.DATA_KEY), N.off(this._element, this.constructor.EVENT_KEY);
                    for (const t of Object.getOwnPropertyNames(this)) this[t] = null
                }
                _queueCallback(t, e, i = !0) {
                    _(t, e, i)
                }
                _getConfig(t) {
                    return t = this._mergeConfigObj(t, this._element), t = this._configAfterMerge(t), this._typeCheckConfig(t), t
                }
                static getInstance(t) {
                    return e.get(r(t), this.DATA_KEY)
                }
                static getOrCreateInstance(t, e = {}) {
                    return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
                }
                static get VERSION() {
                    return "5.3.3"
                }
                static get DATA_KEY() {
                    return `bs.${this.NAME}`
                }
                static get EVENT_KEY() {
                    return `.${this.DATA_KEY}`
                }
                static eventName(t) {
                    return `${t}${this.EVENT_KEY}`
                }
            }
            const B = t => {
                    let e = t.getAttribute("data-bs-target");
                    if (!e || "#" === e) {
                        let i = t.getAttribute("href");
                        if (!i || !i.includes("#") && !i.startsWith(".")) return null;
                        i.includes("#") && !i.startsWith("#") && (i = `#${i.split("#")[1]}`), e = i && "#" !== i ? i.trim() : null
                    }
                    return e ? e.split(",").map((t => n(t))).join(",") : null
                },
                z = {
                    find: (t, e = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(e, t)),
                    findOne: (t, e = document.documentElement) => Element.prototype.querySelector.call(e, t),
                    children: (t, e) => [].concat(...t.children).filter((t => t.matches(e))),
                    parents(t, e) {
                        const i = [];
                        let n = t.parentNode.closest(e);
                        for (; n;) i.push(n), n = n.parentNode.closest(e);
                        return i
                    },
                    prev(t, e) {
                        let i = t.previousElementSibling;
                        for (; i;) {
                            if (i.matches(e)) return [i];
                            i = i.previousElementSibling
                        }
                        return []
                    },
                    next(t, e) {
                        let i = t.nextElementSibling;
                        for (; i;) {
                            if (i.matches(e)) return [i];
                            i = i.nextElementSibling
                        }
                        return []
                    },
                    focusableChildren(t) {
                        const e = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((t => `${t}:not([tabindex^="-"])`)).join(",");
                        return this.find(e, t).filter((t => !l(t) && a(t)))
                    },
                    getSelectorFromElement(t) {
                        const e = B(t);
                        return e && z.findOne(e) ? e : null
                    },
                    getElementFromSelector(t) {
                        const e = B(t);
                        return e ? z.findOne(e) : null
                    },
                    getMultipleElementsFromSelector(t) {
                        const e = B(t);
                        return e ? z.find(e) : []
                    }
                },
                R = (t, e = "hide") => {
                    const i = `click.dismiss${t.EVENT_KEY}`,
                        n = t.NAME;
                    N.on(document, i, `[data-bs-dismiss="${n}"]`, (function (i) {
                        if (["A", "AREA"].includes(this.tagName) && i.preventDefault(), l(this)) return;
                        const s = z.getElementFromSelector(this) || this.closest(`.${n}`);
                        t.getOrCreateInstance(s)[e]()
                    }))
                },
                q = ".bs.alert",
                V = `close${q}`,
                K = `closed${q}`;
            class Q extends W {
                static get NAME() {
                    return "alert"
                }
                close() {
                    if (N.trigger(this._element, V).defaultPrevented) return;
                    this._element.classList.remove("show");
                    const t = this._element.classList.contains("fade");
                    this._queueCallback((() => this._destroyElement()), this._element, t)
                }
                _destroyElement() {
                    this._element.remove(), N.trigger(this._element, K), this.dispose()
                }
                static jQueryInterface(t) {
                    return this.each((function () {
                        const e = Q.getOrCreateInstance(this);
                        if ("string" == typeof t) {
                            if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
                            e[t](this)
                        }
                    }))
                }
            }
            R(Q, "close"), m(Q);
            const X = '[data-bs-toggle="button"]';
            class Y extends W {
                static get NAME() {
                    return "button"
                }
                toggle() {
                    this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"))
                }
                static jQueryInterface(t) {
                    return this.each((function () {
                        const e = Y.getOrCreateInstance(this);
                        "toggle" === t && e[t]()
                    }))
                }
            }
            N.on(document, "click.bs.button.data-api", X, (t => {
                t.preventDefault();
                const e = t.target.closest(X);
                Y.getOrCreateInstance(e).toggle()
            })), m(Y);
            const U = ".bs.swipe",
                G = `touchstart${U}`,
                J = `touchmove${U}`,
                Z = `touchend${U}`,
                tt = `pointerdown${U}`,
                et = `pointerup${U}`,
                it = {
                    endCallback: null,
                    leftCallback: null,
                    rightCallback: null
                },
                nt = {
                    endCallback: "(function|null)",
                    leftCallback: "(function|null)",
                    rightCallback: "(function|null)"
                };
            class st extends H {
                constructor(t, e) {
                    super(), this._element = t, t && st.isSupported() && (this._config = this._getConfig(e), this._deltaX = 0, this._supportPointerEvents = Boolean(window.PointerEvent), this._initEvents())
                }
                static get Default() {
                    return it
                }
                static get DefaultType() {
                    return nt
                }
                static get NAME() {
                    return "swipe"
                }
                dispose() {
                    N.off(this._element, U)
                }
                _start(t) {
                    this._supportPointerEvents ? this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX) : this._deltaX = t.touches[0].clientX
                }
                _end(t) {
                    this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX - this._deltaX), this._handleSwipe(), g(this._config.endCallback)
                }
                _move(t) {
                    this._deltaX = t.touches && t.touches.length > 1 ? 0 : t.touches[0].clientX - this._deltaX
                }
                _handleSwipe() {
                    const t = Math.abs(this._deltaX);
                    if (t <= 40) return;
                    const e = t / this._deltaX;
                    this._deltaX = 0, e && g(e > 0 ? this._config.rightCallback : this._config.leftCallback)
                }
                _initEvents() {
                    this._supportPointerEvents ? (N.on(this._element, tt, (t => this._start(t))), N.on(this._element, et, (t => this._end(t))), this._element.classList.add("pointer-event")) : (N.on(this._element, G, (t => this._start(t))), N.on(this._element, J, (t => this._move(t))), N.on(this._element, Z, (t => this._end(t))))
                }
                _eventIsPointerPenTouch(t) {
                    return this._supportPointerEvents && ("pen" === t.pointerType || "touch" === t.pointerType)
                }
                static isSupported() {
                    return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0
                }
            }
            const ot = ".bs.carousel",
                rt = ".data-api",
                at = "next",
                lt = "prev",
                ct = "left",
                ht = "right",
                dt = `slide${ot}`,
                ut = `slid${ot}`,
                ft = `keydown${ot}`,
                pt = `mouseenter${ot}`,
                mt = `mouseleave${ot}`,
                gt = `dragstart${ot}`,
                _t = `load${ot}${rt}`,
                bt = `click${ot}${rt}`,
                vt = "carousel",
                yt = "active",
                wt = ".active",
                At = ".carousel-item",
                Et = wt + At,
                Tt = {
                    ArrowLeft: ht,
                    ArrowRight: ct
                },
                Ct = {
                    interval: 5e3,
                    keyboard: !0,
                    pause: "hover",
                    ride: !1,
                    touch: !0,
                    wrap: !0
                },
                Ot = {
                    interval: "(number|boolean)",
                    keyboard: "boolean",
                    pause: "(string|boolean)",
                    ride: "(boolean|string)",
                    touch: "boolean",
                    wrap: "boolean"
                };
            class xt extends W {
                constructor(t, e) {
                    super(t, e), this._interval = null, this._activeElement = null, this._isSliding = !1, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = z.findOne(".carousel-indicators", this._element), this._addEventListeners(), this._config.ride === vt && this.cycle()
                }
                static get Default() {
                    return Ct
                }
                static get DefaultType() {
                    return Ot
                }
                static get NAME() {
                    return "carousel"
                }
                next() {
                    this._slide(at)
                }
                nextWhenVisible() {
                    !document.hidden && a(this._element) && this.next()
                }
                prev() {
                    this._slide(lt)
                }
                pause() {
                    this._isSliding && s(this._element), this._clearInterval()
                }
                cycle() {
                    this._clearInterval(), this._updateInterval(), this._interval = setInterval((() => this.nextWhenVisible()), this._config.interval)
                }
                _maybeEnableCycle() {
                    this._config.ride && (this._isSliding ? N.one(this._element, ut, (() => this.cycle())) : this.cycle())
                }
                to(t) {
                    const e = this._getItems();
                    if (t > e.length - 1 || t < 0) return;
                    if (this._isSliding) return void N.one(this._element, ut, (() => this.to(t)));
                    const i = this._getItemIndex(this._getActive());
                    if (i === t) return;
                    const n = t > i ? at : lt;
                    this._slide(n, e[t])
                }
                dispose() {
                    this._swipeHelper && this._swipeHelper.dispose(), super.dispose()
                }
                _configAfterMerge(t) {
                    return t.defaultInterval = t.interval, t
                }
                _addEventListeners() {
                    this._config.keyboard && N.on(this._element, ft, (t => this._keydown(t))), "hover" === this._config.pause && (N.on(this._element, pt, (() => this.pause())), N.on(this._element, mt, (() => this._maybeEnableCycle()))), this._config.touch && st.isSupported() && this._addTouchEventListeners()
                }
                _addTouchEventListeners() {
                    for (const t of z.find(".carousel-item img", this._element)) N.on(t, gt, (t => t.preventDefault()));
                    const t = {
                        leftCallback: () => this._slide(this._directionToOrder(ct)),
                        rightCallback: () => this._slide(this._directionToOrder(ht)),
                        endCallback: () => {
                            "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout((() => this._maybeEnableCycle()), 500 + this._config.interval))
                        }
                    };
                    this._swipeHelper = new st(this._element, t)
                }
                _keydown(t) {
                    if (/input|textarea/i.test(t.target.tagName)) return;
                    const e = Tt[t.key];
                    e && (t.preventDefault(), this._slide(this._directionToOrder(e)))
                }
                _getItemIndex(t) {
                    return this._getItems().indexOf(t)
                }
                _setActiveIndicatorElement(t) {
                    if (!this._indicatorsElement) return;
                    const e = z.findOne(wt, this._indicatorsElement);
                    e.classList.remove(yt), e.removeAttribute("aria-current");
                    const i = z.findOne(`[data-bs-slide-to="${t}"]`, this._indicatorsElement);
                    i && (i.classList.add(yt), i.setAttribute("aria-current", "true"))
                }
                _updateInterval() {
                    const t = this._activeElement || this._getActive();
                    if (!t) return;
                    const e = Number.parseInt(t.getAttribute("data-bs-interval"), 10);
                    this._config.interval = e || this._config.defaultInterval
                }
                _slide(t, e = null) {
                    if (this._isSliding) return;
                    const i = this._getActive(),
                        n = t === at,
                        s = e || b(this._getItems(), i, n, this._config.wrap);
                    if (s === i) return;
                    const o = this._getItemIndex(s),
                        r = e => N.trigger(this._element, e, {
                            relatedTarget: s,
                            direction: this._orderToDirection(t),
                            from: this._getItemIndex(i),
                            to: o
                        });
                    if (r(dt).defaultPrevented) return;
                    if (!i || !s) return;
                    const a = Boolean(this._interval);
                    this.pause(), this._isSliding = !0, this._setActiveIndicatorElement(o), this._activeElement = s;
                    const l = n ? "carousel-item-start" : "carousel-item-end",
                        c = n ? "carousel-item-next" : "carousel-item-prev";
                    s.classList.add(c), d(s), i.classList.add(l), s.classList.add(l), this._queueCallback((() => {
                        s.classList.remove(l, c), s.classList.add(yt), i.classList.remove(yt, c, l), this._isSliding = !1, r(ut)
                    }), i, this._isAnimated()), a && this.cycle()
                }
                _isAnimated() {
                    return this._element.classList.contains("slide")
                }
                _getActive() {
                    return z.findOne(Et, this._element)
                }
                _getItems() {
                    return z.find(At, this._element)
                }
                _clearInterval() {
                    this._interval && (clearInterval(this._interval), this._interval = null)
                }
                _directionToOrder(t) {
                    return p() ? t === ct ? lt : at : t === ct ? at : lt
                }
                _orderToDirection(t) {
                    return p() ? t === lt ? ct : ht : t === lt ? ht : ct
                }
                static jQueryInterface(t) {
                    return this.each((function () {
                        const e = xt.getOrCreateInstance(this, t);
                        if ("number" != typeof t) {
                            if ("string" == typeof t) {
                                if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
                                e[t]()
                            }
                        } else e.to(t)
                    }))
                }
            }
            N.on(document, bt, "[data-bs-slide], [data-bs-slide-to]", (function (t) {
                const e = z.getElementFromSelector(this);
                if (!e || !e.classList.contains(vt)) return;
                t.preventDefault();
                const i = xt.getOrCreateInstance(e),
                    n = this.getAttribute("data-bs-slide-to");
                return n ? (i.to(n), void i._maybeEnableCycle()) : "next" === F.getDataAttribute(this, "slide") ? (i.next(), void i._maybeEnableCycle()) : (i.prev(), void i._maybeEnableCycle())
            })), N.on(window, _t, (() => {
                const t = z.find('[data-bs-ride="carousel"]');
                for (const e of t) xt.getOrCreateInstance(e)
            })), m(xt);
            const kt = ".bs.collapse",
                Lt = `show${kt}`,
                St = `shown${kt}`,
                Dt = `hide${kt}`,
                $t = `hidden${kt}`,
                It = `click${kt}.data-api`,
                Nt = "show",
                Pt = "collapse",
                jt = "collapsing",
                Mt = `:scope .${Pt} .${Pt}`,
                Ft = '[data-bs-toggle="collapse"]',
                Ht = {
                    parent: null,
                    toggle: !0
                },
                Wt = {
                    parent: "(null|element)",
                    toggle: "boolean"
                };
            class Bt extends W {
                constructor(t, e) {
                    super(t, e), this._isTransitioning = !1, this._triggerArray = [];
                    const i = z.find(Ft);
                    for (const t of i) {
                        const e = z.getSelectorFromElement(t),
                            i = z.find(e).filter((t => t === this._element));
                        null !== e && i.length && this._triggerArray.push(t)
                    }
                    this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle()
                }
                static get Default() {
                    return Ht
                }
                static get DefaultType() {
                    return Wt
                }
                static get NAME() {
                    return "collapse"
                }
                toggle() {
                    this._isShown() ? this.hide() : this.show()
                }
                show() {
                    if (this._isTransitioning || this._isShown()) return;
                    let t = [];
                    if (this._config.parent && (t = this._getFirstLevelChildren(".collapse.show, .collapse.collapsing").filter((t => t !== this._element)).map((t => Bt.getOrCreateInstance(t, {
                            toggle: !1
                        })))), t.length && t[0]._isTransitioning) return;
                    if (N.trigger(this._element, Lt).defaultPrevented) return;
                    for (const e of t) e.hide();
                    const e = this._getDimension();
                    this._element.classList.remove(Pt), this._element.classList.add(jt), this._element.style[e] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;
                    const i = `scroll${e[0].toUpperCase()+e.slice(1)}`;
                    this._queueCallback((() => {
                        this._isTransitioning = !1, this._element.classList.remove(jt), this._element.classList.add(Pt, Nt), this._element.style[e] = "", N.trigger(this._element, St)
                    }), this._element, !0), this._element.style[e] = `${this._element[i]}px`
                }
                hide() {
                        if (this._isTransitioning || !this._isShown()) return;
                        if (N.trigger(this._element, Dt).defaultPrevented) return;
                        const t = this._getDimension();
                        this._element.style[t] = `${this._element.getBoundingClientRect()[t]}px`, d(this._element), this._element.classList.add(jt), this._element.classList.remove(Pt, Nt);
                        for (const t of this._triggerArray) {
                            const e = z.getElementFromSelector(t);
                            e && !this._isShown(e) && this._addAriaAndCollapsedClass([t], !1)
                        }
                        this._isTransitioning = !0, this._element.style[t] = "", this._queueCallback((() => {
                                        this._isTransitioning = !1, this._element.classList
